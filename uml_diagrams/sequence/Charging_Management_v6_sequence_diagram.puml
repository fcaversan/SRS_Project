@startuml
!theme plain
title Charging_Management_v6 Architecture (Service-Oriented) - Improved

autonumber

actor User
participant App
participant APIGateway as "API Gateway"
participant ChargingService as "Charging Service"
participant SettingsService as "Settings Service"
participant ScheduleService as "Schedule Service"
participant VehicleGateway as "Vehicle Gateway"
database ChargingDB
database SettingsDB
database SchedulesDB
participant MapService as "Map & Station Service"

ref over APIGateway
  **Common Flow:** Authentication & Authorization
  For every request from the App, the API Gateway
  validates the Bearer token and user permissions
  before forwarding to the appropriate internal service.
end ref

group Remote Charging Control & State Management (FR-CHG-001, FR-CHG-002, State Transitions)

    User -> App: Tap "Start Charging"
    App -> APIGateway: POST /v1/vehicles/{id}/commands/start_charge
    note right of APIGateway: Auth check, then route to Charging Service
    APIGateway -> ChargingService: startChargingSession(vehicleId)
    ChargingService -> VehicleGateway: getVehicleStatus(vehicleId)
    VehicleGateway --> ChargingService: return { isPluggedIn: true, isReady: true }

    alt Vehicle is plugged-in and ready
        ChargingService -> ChargingDB: createSession(vehicleId, state: INITIALIZED)
        note right of ChargingService: Formalizes session state transition.
        ChargingService -> VehicleGateway: sendCommand(vehicleId, 'start_charge')
        note left of VehicleGateway: Asynchronous command
        VehicleGateway --> ChargingService: ackCommand()
        ChargingService -> ChargingDB: updateSession(sessionId, state: CONNECTING)
        ChargingService --> APIGateway: 202 Accepted (Command sent, session pending)
        APIGateway --> App: 202 Accepted
        App -> User: Display "Starting charging session..."
        
        loop Poll for session status
            App -> APIGateway: GET /v1/vehicles/{id}/state/charge
            APIGateway -> ChargingService: getChargeState(vehicleId)
            ChargingService -> ChargingDB: findActiveSession(vehicleId)
            ChargingDB --> ChargingService: return session { state: 'CHARGING', ... }
            note right of ChargingService: State has transitioned to CHARGING
            ChargingService --> APIGateway: return ChargeStateDTO { state: 'CHARGING', soc: 55, ... }
            APIGateway --> App: 200 OK (ChargeStateDTO)
            App -> User: Update display to show 'Charging' status & metrics
        end
        
    else Vehicle not ready (e.g., not plugged in)
        ChargingService --> APIGateway: 409 Conflict (Error DTO)
        APIGateway --> App: 409 Conflict (Error: Not plugged in)
        App -> User: Display error: "Vehicle is not plugged into a compatible charger."
    end

    ...later...

    User -> App: Tap "Stop Charging"
    App -> APIGateway: POST /v1/vehicles/{id}/commands/stop_charge
    APIGateway -> ChargingService: stopChargingSession(vehicleId)
    ChargingService -> VehicleGateway: sendCommand(vehicleId, 'stop_charge')
    ChargingService -> ChargingDB: updateSession(sessionId, state: STOPPING)
    ChargingService --> APIGateway: 202 Accepted
    APIGateway --> App: 202 Accepted
    App -> User: Display "Stopping charging session..."
    note over ChargingService, ChargingDB: A background process would later transition\nthe state to COMPLETED or FAULTED.
end

group Monitor Active Charging Session (FR-CHG-003)
    User -> App: View charging screen
    loop Periodically (e.g., every 15s)
        App -> APIGateway: GET /v1/vehicles/{id}/state/charge
        APIGateway -> ChargingService: getChargeState(vehicleId)
        alt Session data available
            ChargingService -> VehicleGateway: getLiveMetrics(vehicleId)
            VehicleGateway --> ChargingService: return {soc, rate_kw, voltage, amperage}
            ChargingService -> ChargingDB: findActiveSession(vehicleId)
            ChargingDB --> ChargingService: return {time_to_full, state}
            ChargingService --> APIGateway: return ChargeStateDTO {soc, time_to_full, rate_kw, ...}
            APIGateway --> App: 200 OK (ChargeStateDTO)
            App -> User: Update display with SoC, ETA, rate, etc.
        else Service unavailable
            ChargingService --> APIGateway: 503 Service Unavailable
            APIGateway --> App: 503 Service Unavailable
            App -> User: Display stale data with "Could not refresh status"
        end
    end
end

group Manage Charging Settings (FR-CHG-004)
    User -> App: Open "Charging Settings"
    App -> APIGateway: GET /v1/vehicles/{id}/settings/charge
    APIGateway -> SettingsService: getChargeSettings(vehicleId)
    SettingsService -> SettingsDB: findSettingsByVehicleId(id)
    SettingsDB --> SettingsService: return { dailyLimit: 80 }
    SettingsService --> APIGateway: return SettingsDTO
    APIGateway --> App: 200 OK (SettingsDTO)
    App -> User: Display charge limit slider (default 80%)
    
    User -> App: Set new daily charge limit to 90%
    App -> APIGateway: PUT /v1/vehicles/{id}/settings/charge (body: {daily_limit: 90})
    APIGateway -> SettingsService: updateChargeSettings(vehicleId, settings)
    SettingsService -> SettingsDB: updateSettings(vehicleId, {dailyLimit: 90})
    SettingsService --> APIGateway: 200 OK
    APIGateway --> App: 200 OK
    App -> User: Display "Daily charge limit updated to 90%"
    
    User -> App: Tap "Charge to 100% for Trip"
    App -> APIGateway: POST /v1/vehicles/{id}/commands/charge_to_full
    APIGateway -> SettingsService: setOneTimeChargeLimit(vehicleId, 100)
    note right of SettingsService: This command sets a temporary override.
    SettingsService -> SettingsDB: setOverride(vehicleId, {limit: 100})
    SettingsService --> APIGateway: 200 OK
    APIGateway --> App: 200 OK
    App -> User: Display "Trip mode activated. Vehicle will charge to 100%."
end

group Manage Charging Schedules (FR-CHG-005) - Complete CRUD
    User -> App: Navigate to "Charging Schedules"
    App -> APIGateway: GET /v1/vehicles/{id}/schedules
    APIGateway -> ScheduleService: listSchedules(vehicleId)
    ScheduleService -> SchedulesDB: findSchedulesByVehicleId(id)
    SchedulesDB --> ScheduleService: return [schedules]
    ScheduleService --> APIGateway: return ScheduleListDTO
    APIGateway --> App: 200 OK (ScheduleListDTO)
    App -> User: Display list of existing schedules

    ...Create...
    User -> App: Create "Ready by 7:00 AM" schedule
    App -> APIGateway: POST /v1/vehicles/{id}/schedules (body: {type: "ready-by", time: "07:00"})
    APIGateway -> ScheduleService: createSchedule(vehicleId, scheduleData)
    ScheduleService -> SchedulesDB: insertSchedule(schedule)
    SchedulesDB --> ScheduleService: return newScheduleId
    ScheduleService --> APIGateway: 201 Created
    APIGateway --> App: 201 Created
    App -> App: Refresh schedule list (via another GET)
    App -> User: Display "Schedule created"
    
    ...Edit...
    User -> App: Edit schedule to "Ready by 6:30 AM"
    App -> APIGateway: PUT /v1/vehicles/{id}/schedules/{scheduleId} (body: {time: "06:30"})
    APIGateway -> ScheduleService: updateSchedule(vehicleId, scheduleId, data)
    ScheduleService -> SchedulesDB: updateSchedule(scheduleId, data)
    SchedulesDB --> ScheduleService: return success
    ScheduleService --> APIGateway: 200 OK
    APIGateway --> App: 200 OK
    App -> User: Display "Schedule updated"

    ...Delete...
    User -> App: Delete schedule
    App -> APIGateway: DELETE /v1/vehicles/{id}/schedules/{scheduleId}
    APIGateway -> ScheduleService: deleteSchedule(vehicleId, scheduleId)
    ScheduleService -> SchedulesDB: deleteScheduleById(scheduleId)
    SchedulesDB --> ScheduleService: return success
    ScheduleService --> APIGateway: 204 No Content
    APIGateway --> App: 204 No Content
    App -> User: Display "Schedule deleted"
end

group Find Charging Stations (FR-CHG-006, FR-CHG-007, FR-CHG-008)
    User -> App: Open "Charger Map"
    App -> APIGateway: GET /v1/chargers?lat={lat}&lng={lng}&connector=CCS&power_min=150
    APIGateway -> MapService: findStations(location, filters)
    
    note over MapService
      **Data Aggregation Strategy (FR-CHG-008):**
      1. Queries internal cache for station data.
      2. If data is stale or for specific real-time networks,
         it may trigger a live fetch from a 3rd party
         Charging Point Operator (CPO) API to get availability.
    end note
    
    alt Stations found
        MapService --> APIGateway: return StationList DTO (with location, power, availability, lastUpdated)
        APIGateway --> App: 200 OK (JSON with station list and freshness timestamps)
        App -> User: Display map with filtered charger pins\n<font size=10>(e.g., "Available, updated 2 mins ago")
    else Service error or no stations found
        MapService --> APIGateway: Error or empty list
        APIGateway --> App: 500 Server Error or 200 OK (empty list)
        App -> User: Display error: "Could not load chargers or none found nearby."
    end
end
@enduml