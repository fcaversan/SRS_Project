@startuml

' Style settings for better readability
skinparam classAttributeIconSize 0
skinparam linetype ortho
skinparam shadowing false
skinparam roundcorner 10
skinparam defaultFontName "Segoe UI"
skinparam class {
    BackgroundColor White
    ArrowColor #262626
    BorderColor #262626
}
skinparam interface {
    BackgroundColor lightgreen
    ArrowColor #262626
    BorderColor #262626
}
skinparam state {
    BackgroundColor lightyellow
    BorderColor #505050
}

' ---------- Enumerations for States, Types, and Locations ----------
enum LockState {
  LOCKED
  UNLOCKED
}

enum ComponentState {
  ACTIVE
  INACTIVE
}

enum ClimateSystemState {
    OFF
    ACTIVE
    PRECONDITIONING
}

enum TrunkLocation {
  FRONT
  REAR
}

enum DefrosterLocation {
  FRONT
  REAR
}

enum ElementLocation {
    DRIVER_SEAT
    PASSENGER_SEAT
    STEERING_WHEEL
}

enum PlugStatus {
    PLUGGED_IN
    UNPLUGGED
}

enum CommandStatus {
    SUCCESS
    PENDING
    FAILURE_AUTHENTICATION
    FAILURE_VEHICLE_UNREACHABLE
    FAILURE_INVALID_PRECONDITION
    FAILURE_TIMEOUT
    FAILURE_COMPONENT_NOT_EQUIPPED
}
note right
  **IMPROVEMENT (Feedback #2):**
  Added `FAILURE_COMPONENT_NOT_EQUIPPED`
  to support more granular error handling for
  requests involving optional vehicle hardware.
end note

enum VehicleState {
    PARKED
    DRIVING
    CHARGING
}

enum HeatingLevel {
    OFF
    LOW
    MEDIUM
    HIGH
}

enum EquipmentType {
    HEATED_SEATS
    HEATED_STEERING_WHEEL
    PANORAMIC_ROOF
}

' ---------- Interfaces for Abstraction Refinement ----------
interface IToggleable <<(I,lightgreen)>> {
  + activate(): void
  + deactivate(): void
}

interface ILevelAdjustable <<(I,lightgreen)>> {
  + setLevel(level: HeatingLevel): void
  + getLevel(): HeatingLevel
}

' ---------- Data Transfer Objects (DTOs) and Value Objects ----------
class AuthToken <<(V,orchid) Value Object>> {
  + tokenValue: string
  + expiryDate: datetime
}

class CommandAck <<(D,orchid) DTO>> {
    + commandID: UUID
    + receivedTimestamp: datetime
    + message: string
}
note top
  **IMPROVEMENT (Feedback #3 & #4):**
  Represents the initial synchronous response (e.g., HTTP 202)
  in an asynchronous system, decoupling the request from the
  final result which arrives later via a push notification.
end note

class NotificationPayload <<(D,orchid) DTO>> {
    + commandID: UUID
    + finalStatus: CommandStatus
    + message: string
    + timestamp: datetime
}

class ElementSetting <<(D,orchid) DTO>> {
    + active: bool
    + level: HeatingLevel
}

class ClimateSettings <<(D,orchid) DTO>> {
    + targetTemperature: float
    + heatedElements: map<ElementLocation, ElementSetting>
    + defrosters: map<DefrosterLocation, bool>
}

' ---------- Services and Main Classes ----------
class AuthenticationService {
  + validateToken(token: AuthToken): bool
}

class NotificationService {
    + sendPushNotification(deviceID: string, payload: NotificationPayload): void
}
note right
  **IMPROVEMENT (Feedback #3 & #4):**
  This new service explicitly models the
  asynchronous push notification mechanism,
  clarifying how final command results are
  communicated back to the mobile device.
end note

class MobileDevice {
  + deviceID: string
  --
  + sendLockRequest(authToken: AuthToken, vehicleID: string): CommandAck
  + sendUnlockRequest(authToken: AuthToken, vehicleID: string): CommandAck
  + sendClimateRequest(authToken: AuthToken, vehicleID: string, settings: ClimateSettings): CommandAck
  + sendTrunkRequest(authToken: AuthToken, vehicleID: string, location: TrunkLocation): CommandAck
  + sendAlertRequest(authToken: AuthToken, vehicleID: string): CommandAck
  + receivePushNotification(payload: NotificationPayload): void
  + displayWarning(message: string): void
  + triggerHapticFeedback(): void
}

class RemoteControlSystem {
  --
  + queueLockRequest(authToken: AuthToken, vehicleID: string): CommandAck
  + queueUnlockRequest(authToken: AuthToken, vehicleID: string): CommandAck
  + queueClimateRequest(authToken: AuthToken, vehicleID: string, settings: ClimateSettings): CommandAck
  + queueTrunkRequest(authToken: AuthToken, vehicleID: string, location: TrunkLocation): CommandAck
  + queueAlertRequest(authToken: AuthToken, vehicleID: string): CommandAck
}
note bottom of RemoteControlSystem
  **IMPROVEMENT (Feedback #3):** This class represents the **Cloud API Backend**.
  Method names changed to `queue...` to reflect the asynchronous,
  message-queued nature of the architecture.
end note


class Vehicle {
  + vin: string
  + model: string
  + equipment: List<EquipmentType>
  - state: VehicleState
  --
  + getState(): VehicleState
  + hasEquipment(type: EquipmentType): bool
}
note left of Vehicle::equipment
  **IMPROVEMENT (Feedback #2):**
  Allows the system to verify if a vehicle
  is equipped with a feature before
  attempting to activate it.
end note


' ---------- Vehicle Subsystem Classes ----------
class DoorSystem {
  - lockState: LockState
  + lock(): void
  + unlock(): void
}

class ClimateControlSystem {
  - state: ClimateSystemState
  + activate(): void
  + deactivate(): void
  + setTargetTemperature(temp: float): void
}

abstract class HeatedElement {
  # location: ElementLocation
  # state: ComponentState
}

class HeatedSeat {
  - heatingLevel: HeatingLevel
}

class HeatedSteeringWheel {
}

class Defroster {
  - location: DefrosterLocation
}

class Trunk {
    - location: TrunkLocation
    + open(): void
}

class ExteriorAlertSystem {
  + triggerAlert(): void
}

class PowerSystem {
    - plugStatus: PlugStatus
    + isPluggedIn(): bool
}


' ---------- Relationships and Multiplicity ----------

' System-level relationships
RemoteControlSystem "1" -- "0..*" MobileDevice : communicates with
RemoteControlSystem "1" -- "0..*" Vehicle : controls
RemoteControlSystem "1" --> "1" AuthenticationService : uses
RemoteControlSystem "1" --> "1" NotificationService : uses

' Vehicle composition
Vehicle "1" *-- "1" DoorSystem
Vehicle "1" *-- "1" ClimateControlSystem
Vehicle "1" *-- "2" Trunk
Vehicle "1" *-- "1" ExteriorAlertSystem
Vehicle "1" *-- "1" PowerSystem

' ClimateControlSystem composition
ClimateControlSystem "1" *-- "0..*" HeatedElement
ClimateControlSystem "1" *-- "2" Defroster

' HeatedElement abstraction refinement
IToggleable <|.. HeatedElement
ILevelAdjustable <|.. HeatedSeat
HeatedElement <|-- HeatedSeat
HeatedElement <|-- HeatedSteeringWheel
IToggleable <|.. Defroster

' Dependency on DTOs and Value Objects
RemoteControlSystem ..> CommandAck
MobileDevice ..> CommandAck
MobileDevice ..> NotificationPayload
NotificationService ..> NotificationPayload
RemoteControlSystem ..> ClimateSettings
MobileDevice ..> ClimateSettings
MobileDevice ..> AuthToken
RemoteControlSystem ..> AuthToken
ClimateSettings ..> ElementSetting
ElementSetting ..> HeatingLevel


' ---------- Vehicle State Machine Diagram ----------
state "Vehicle State Machine" as VSM {
  note left
    **IMPROVEMENT (Feedback #1):**
    Formal State Machine Diagram for the `Vehicle` class.
    It explicitly defines states, transitions, and which
    remote commands are permissible in each state,
    enforcing business rules like "trunk can only be
    opened when parked".
  end note

  [*] --> PARKED

  state PARKED {
    entry / allow: lockDoors(), unlockDoors()
    entry / allow: openTrunk(), closeTrunk()
    entry / allow: startClimatePreconditioning()
    entry / allow: triggerAlert()
  }

  state DRIVING {
    entry / allow: lockDoors(), unlockDoors()
    entry / allow: triggerAlert()
    exit / disallow: openTrunk()
  }

  state CHARGING {
    entry / allow: lockDoors(), unlockDoors()
    entry / allow: startClimatePreconditioning()
    exit / disallow: openTrunk()
  }

  PARKED --> DRIVING : userStartsDriving()
  DRIVING --> PARKED : userParksVehicle()
  PARKED --> CHARGING : userPlugsInCharger()
  CHARGING --> PARKED : userUnplugsCharger()
}

@enduml